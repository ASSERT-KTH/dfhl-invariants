diff --git a/src/pSeudoEth_exp/UniswapV2Pair.sol b/src/pSeudoEth_exp/UniswapV2Pair_patch.sol
index b94e33e..54fec75 100644
--- a/src/pSeudoEth_exp/UniswapV2Pair.sol
+++ b/src/pSeudoEth_exp/UniswapV2Pair_patch.sol
@@ -1,5 +1,29 @@
 // File: contracts/interfaces/IUniswapV2Pair.sol
 
+/**
+ * @dev
+ * Vulnerability
+ * In the exploit, the attacker temporarily increases the balance using a flash loan.
+ * That makes it look like there’s extra money
+ * Then they call skim() to steal it.
+ *
+ * Patch
+ * added two require() checks to the `skim()` function
+ * to ensure that the current token balances are not
+ * more than 10% greater than the internal reserves.
+ * balance0 / balance1: how many tokens the contract actually holds right now.
+ * reserve0 / reserve1:how many tokens the contract should have according to the pool’s reserves.
+ * ````
+ *         uint balance0 = IERC20(_token0).balanceOf(address(this));
+ *         uint balance1 = IERC20(_token1).balanceOf(address(this));
+ *         require(balance0 - reserve0 <= reserve0 / 10, "UniswapV2: EXCESSIVE_IMBALANCE_TOKEN0");
+ *         require(balance1 - reserve1 <= reserve1 / 10, "UniswapV2: EXCESSIVE_IMBALANCE_TOKEN1");
+ * ```
+ * These checks prevent skim() from being called during
+ * large temporary imbalances (ie those caused by flash loans),
+ * which were the root cause of the exploit.
+ * ' By allowing only a small imbalance (10%), we block large manipulations like this.
+ */
 pragma solidity >=0.5.0;
 
 interface IUniswapV2Pair {
@@ -344,7 +368,7 @@ interface IUniswapV2Callee {
 
 pragma solidity =0.5.16;
 
-contract UniswapV2Pair_original is IUniswapV2Pair, UniswapV2ERC20 {
+contract UniswapV2Pair_patch is IUniswapV2Pair, UniswapV2ERC20 {
     using SafeMath for uint256;
     using UQ112x112 for uint224;
 
@@ -538,6 +562,12 @@ contract UniswapV2Pair_original is IUniswapV2Pair, UniswapV2ERC20 {
     ) external lock {
         address _token0 = token0; // gas savings
         address _token1 = token1; // gas savings
+
+        uint256 balance0 = IERC20(_token0).balanceOf(address(this));
+        uint256 balance1 = IERC20(_token1).balanceOf(address(this));
+        require(balance0 - reserve0 <= reserve0 / 10, "UniswapV2: EXCESSIVE_IMBALANCE_TOKEN0");
+        require(balance1 - reserve1 <= reserve1 / 10, "UniswapV2: EXCESSIVE_IMBALANCE_TOKEN1");
+
         _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
         _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
     }
