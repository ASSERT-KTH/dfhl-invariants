diff --git a/src/WIFCOIN_ETH_exp/contracts/WIFStaking.sol b/src/WIFCOIN_ETH_exp/contracts/WIFStaking_patch.sol
index 07737c8..0c52295 100644
--- a/src/WIFCOIN_ETH_exp/contracts/WIFStaking.sol
+++ b/src/WIFCOIN_ETH_exp/contracts/WIFStaking_patch.sol
@@ -6,6 +6,22 @@
 
 // OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)
 
+/**
+ * @dev
+ * Vulnerability:
+ * Double claimEarned, Each time the claimEarned function is called,
+ * the code iterates through all the stakes and accumulates the calculated _earned amount.
+ * However, after calculating the rewards, the already calculated rewards are not marked as claimed.
+ * As a result, the next time claimEarned is called,
+ * it will recalculate those already claimed rewards, allowing users to claim rewards multiple times.
+ *
+ * Patch:
+ * require(_earned > totalRewardsPerWalletPerPlan[_stakingId][msg.sender], "Rewards already claimed");
+ * This ensures users cannot claim the same rewards twice
+ *  _earned:This is the total rewards calculated for the user in this claim attempt.
+ * totalRewardsPerWalletPerPlan[_stakingId][msg.sender]: This is the amount of rewards
+ * the user has already claimed for this staking plan.
+ */
 pragma solidity ^0.8.0;
 
 // CAUTION
@@ -814,7 +830,7 @@ abstract contract IERC20Staking is ReentrancyGuard, Ownable {
     function emergencyWithdraw(uint256 _stakingId, uint256 _amount) public virtual;
 }
 
-contract WIFStaking_original is IERC20Staking {
+contract WIFStaking_patch is IERC20Staking {
     using SafeMath for uint256;
     using SafeERC20 for IERC20;
 
@@ -974,8 +990,8 @@ contract WIFStaking_original is IERC20Staking {
 
             _staking.stakeAt = block.timestamp;
         }
-
         require(_earned > 0, "There is no amount to claim");
+        require(_earned > totalRewardsPerWalletPerPlan[_stakingId][msg.sender], "Rewards already claimed");
 
         uint256 burnAmount = _earned.mul(_burnRate).div(100);
         IERC20(stakingToken).transfer(BURN_ADDRESS, burnAmount);
