diff --git a/src/Nimbus_exp/NimbusPair.sol b/src/Nimbus_exp/NimbusPair_patch.sol
index 6b64e33..9c42f4b 100644
--- a/src/Nimbus_exp/NimbusPair.sol
+++ b/src/Nimbus_exp/NimbusPair_patch.sol
@@ -1,5 +1,15 @@
 /**
  * Submitted for verification at Etherscan.io on 2021-02-01
+ * Patch Summary 
+ * The original check in swap() function incorrectly used 1000^2 as the scaling factor for reserves,
+ * while the adjusted balances were scaled by 10000, leading to inconsistent math.
+ * This mismatch allowed trades that didn't properly respect the fee and invariant.
+ * patch:
+ * changing 1000^2 to 10000^2 so both sides use the same scaling base.
+ * require(
+ *     balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(10000**2),
+ *     "Nimbus: K"
+ * );
  */
 pragma solidity ^0.8.17;
 
@@ -268,7 +278,7 @@ interface INimbusReferralProgram {
     function recordFee(address token, address recipient, uint256 amount) external;
 }
 
-contract NimbusPair is INimbusPair, NimbusERC20 {
+contract NimbusPair_patch is INimbusPair, NimbusERC20 {
     using SafeMath for uint256;
     using UQ112x112 for uint224;
 
@@ -460,7 +470,8 @@ contract NimbusPair is INimbusPair, NimbusERC20 {
             uint256 balance0Adjusted = balance0.mul(10_000).sub(amount0In.mul(15));
             uint256 balance1Adjusted = balance1.mul(10_000).sub(amount1In.mul(15));
             require(
-                balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2), "Nimbus: K"
+                balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(10_000 ** 2),
+                "Nimbus: K"
             );
         }
 
